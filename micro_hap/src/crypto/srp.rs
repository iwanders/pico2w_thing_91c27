// Okay, this is very much less than ideal.
// SRP from https://github.com/RustCrypto/PAKEs doesn't support no_std
// and I can't find an alternative.
// Since we do all of this for fun anyway and it should not be used for anything real, we might as well try to implement
// this ourselves.
// We also only really need the server side of things... if that matters?

// SRP: https://datatracker.ietf.org/doc/html/rfc2945  <- do not use this, it misses the 'k' multiplication.
// SRP for TLS https://tools.ietf.org/html/rfc5054

// https://docs.rs/srp/latest/srp/server/index.html#usage
// https://github.com/RustCrypto/PAKEs/blob/0be57fc1cf2ecb07f20a1b8bd15d6f9f069e2af8/srp/src/server.rs#L62
//
// We do follow the api from the rust srp implementation.
//
// WU3072.to_be_bytes() gives a copy in big endian bytes, so lets not do that.
// Note everything is in big endian...

// Todo; we might as well remove the lifetimes and hashing function, since we only really care about a single group and
// hash function here.

use core::marker::PhantomData;
use crypto_bigint::const_monty_form;
use crypto_bigint::{NonZero, U3072};

// U3072 is 384 bytes... is that enough to do this logic here?
use sha2::{Digest, Sha512};

// The private secret is only assumed to be this many bytes.
pub const SRP_PRIVATE_SECRET_BYTES: usize = 32;
const SRP_HASH_BYTES: usize = 64;

trait LoadFromBigEndianU8 {
    type Output;
    fn load_from_be(b: &[u8]) -> Self::Output;
    fn store_to_be(&self, b: &mut [u8]);
}
/// Helper macro to make typed newtype wrappers around TLV
macro_rules! implLoad {
    ( $name:ty  ) => {
        impl LoadFromBigEndianU8 for $name {
            type Output = $name;

            fn load_from_be(b: &[u8]) -> Self::Output {
                let mut output = Self::Output::default();
                let len = Self::Output::BYTES;
                use zerocopy::IntoBytes;
                // words: Inner limb array. Stored from least significant to most significant.
                let result_bytes = output.as_words_mut().as_mut_bytes();
                for (r, t) in result_bytes.iter_mut().rev().skip(len - b.len()).zip(b) {
                    *r = *t;
                }
                output
            }
            fn store_to_be(&self, b: &mut [u8]) {
                use zerocopy::IntoBytes;
                // words: Inner limb array. Stored from least significant to most significant.
                let result_bytes = self.as_words().as_bytes();
                for (r, t) in result_bytes.iter().rev().zip(b.iter_mut()) {
                    *t = *r;
                }
            }
        }
    };
}
implLoad!(U3072);
pub struct SrpGroup {
    g: u32,
    n: &'static U3072,
    nz: &'static NonZero<U3072>,
    //k: &'static U3072,
}

pub struct SrpServer<'a, D: Digest> {
    params: &'a SrpGroup,
    d: PhantomData<D>,
}

impl<'a, D: Digest> SrpServer<'a, D> {
    /// Create new server state.
    pub const fn new(params: &'a SrpGroup) -> Self {
        Self {
            params,
            d: PhantomData::<D>,
        }
    }

    /// Get public ephemeral value for sending to the client.
    ///
    /// https://datatracker.ietf.org/doc/html/rfc2945#section-3
    /// k*v + g^b % N
    ///
    /// b: Must be SRP_PRIVATE_SECRET_BYTES bytes long.
    /// public_b: Must be 384 bytes long.
    pub fn compute_public_ephemeral(&self, b: &[u8], v: &[u8], public_b: &mut [u8]) {
        if b.len() != SRP_PRIVATE_SECRET_BYTES {
            panic!(
                "passed a private secret slice that was the incorrect length, expected {}",
                SRP_PRIVATE_SECRET_BYTES
            );
        }

        let bi = U3072::load_from_be(b);
        let v = U3072::load_from_be(v);
        // info!("bi: {:x?}\n", bi);
        // info!("v: {:x?}  b: {}\n", v, v.bits());
        // info!("n: {:x?}  b: {}\n", self.params.n, self.params.n.bits());

        // In https://github.com/RustCrypto/PAKEs/blob/0be57fc1cf2ecb07f20a1b8bd15d6f9f069e2af8/srp/src/server.rs#L94
        // this is two steps:
        // let inter = (k * v) % &self.params.n;
        // (inter + self.params.g.modpow(b, &self.params.n)) % &self.params.n

        // First, lets do inter.
        // let inter = (k * v) % &self.params.n;
        // info!("start of compute_k");
        let k = compute_k::<Sha512>(self.params.g, self.params.n);
        let mut inter = k;
        // info!("end of compute_k");
        // info!("inter: {:x?}, b: {}\n", inter, inter.bits());

        // Now we have k in intermediate, all that remains is mult with v and modulo. Modulo is odd, so;
        // https://docs.rs/crypto-bigint/latest/crypto_bigint/struct.Uint.html#method.mul_mod
        // is applicable:
        let n = NonZero::new(*self.params.n).unwrap();
        inter = inter.mul_mod(&v, &n);
        // info!("k * v % n : {:x?}\n", inter);

        // Next we need  this modpow calculation... this issue shows the way:
        // https://github.com/RustCrypto/crypto-bigint/issues/775
        // g is the generator, b is the input data, and n is the prime. this is g^b % n
        // (inter + self.params.g.modpow(b, &self.params.n)) % &self.params.n
        let right_side = groups::SRP_3072_G_CONST_MONTY
            .pow_bounded_exp(&bi, SRP_PRIVATE_SECRET_BYTES as u32 * 8)
            // .pow(&bi)
            .retrieve();

        // Finally, we add that to the intermediate we already had:
        let combined = inter.add_mod(&right_side, &groups::GROUP_3072.n);
        // info!("combined: {:x?}, {:?}\n", combined, combined.bits());
        //*public_b = combined;
        combined.store_to_be(public_b);
    }

    fn compute_premaster_secret(&self, public_a: &U3072, v: &U3072, u: &U3072, b: &U3072) -> U3072 {
        // Okay, so this is  <premaster secret> = (A * v^u) ^ b % N
        // (A * v^u)
        // let base = (a_pub * v.modpow(u, &self.params.n)) % &self.params.n;
        // base.modpow(b, &self.params.n)
        //
        // Need to convert that to the crypto bigint types.
        // Base first, which is A * v^u
        // v^u requires the montgomery form on a non-const avalue
        // const_monty_form!(v, groups::Srp3072Modulus);
        // doesn't work, is that a bug?
        let v_m = const_monty_form!(v, Srp3072Modulus);
        // let base = v_m.pow(&u).retrieve();
        let base = v_m
            .pow_bounded_exp(&u, SRP_HASH_BYTES as u32 * 8)
            .retrieve();
        let z = public_a.mul_mod(&base, groups::GROUP_3072.nz);

        let base_m = const_monty_form!(z, Srp3072Modulus);

        // base_m.pow(&b).retrieve()
        base_m
            .pow_bounded_exp(&b, SRP_PRIVATE_SECRET_BYTES as u32 * 8)
            .retrieve()
    }

    pub fn compute_shared_secret(
        &self,
        public_b: &[u8],
        b: &[u8],
        v: &[u8],
        public_a: &[u8],
        shared_secret: &mut [u8],
    ) -> Result<(), ()> {
        let u = compute_u::<D>(public_a, public_b);
        //let public_b = U3072::load_from_be(public_b);
        let private_b = U3072::load_from_be(b);
        let public_a = U3072::load_from_be(public_a);
        let v = U3072::load_from_be(v);

        if public_a.rem(&self.params.nz) == U3072::ZERO {
            // This is a malicious A, so return an error.
            return Err(());
        }

        let secret = self.compute_premaster_secret(&public_a, &v, &u, &private_b);
        secret.store_to_be(shared_secret);
        Ok(())
    }

    pub fn session_key(&self, premaster_secret: &[u8], session_key: &mut [u8]) {
        let first_nonzero = premaster_secret
            .iter()
            .position(|p| *p != 0)
            .expect("input premaster may not be zero");
        let premaster_secret = &premaster_secret[first_nonzero..];

        let mut secret_hasher = D::new();
        secret_hasher.update(premaster_secret);
        session_key.copy_from_slice(&secret_hasher.finalize());
    }

    pub fn compute_m1(
        &self,
        username: &str,
        salt: &[u8],
        public_a: &[u8],
        public_b: &[u8],
        session_key: &[u8],
        m1: &mut [u8],
    ) {
        // session_key is hashes shared secret.
        // let mut secret_hasher = D::new();
        // secret_hasher.update(shared_secret);
        // let session_key = secret_hasher.finalize();

        // Hash N and g.
        let mut hash_n = hash_n::<Sha512>().finalize();
        let hash_g = hash_g::<Sha512>().finalize();

        for (n, g) in hash_n
            .as_mut_slice()
            .iter_mut()
            .zip(hash_g.as_slice().iter())
        {
            *n ^= g;
        }

        // Okay that was the first stage, next we hash the username.
        let mut username_hasher = D::new();
        username_hasher.update(username.as_bytes());
        let hash_username = username_hasher.finalize();

        // session_key is hashes shared secret.
        //let mut secret_hasher = D::new();
        //secret_hasher.update(shared_secret);
        //let session_key = secret_hasher.finalize();

        // Now, we can hash all of this.
        let mut m1_hasher = D::new();
        m1_hasher.update(hash_n);
        m1_hasher.update(hash_username);
        m1_hasher.update(salt);
        m1_hasher.update(public_a);
        m1_hasher.update(public_b);
        m1_hasher.update(session_key);
        m1.copy_from_slice(m1_hasher.finalize().as_slice());
    }

    pub fn compute_m2(
        &self,
        public_a: &[u8],
        session_key: &[u8],
        client_proof_m1: &[u8],
        m2: &mut [u8],
    ) {
        // Hash of A, m, session_key
        // session_key is hashes shared secret.
        // let mut secret_hasher = D::new();
        // secret_hasher.update(shared_secret);
        // let session_key = secret_hasher.finalize();

        let mut hasher = D::new();
        hasher.update(public_a);
        hasher.update(client_proof_m1);
        hasher.update(session_key);
        let hash_result = hasher.finalize();
        m2.copy_from_slice(&hash_result.as_slice())
    }
}

fn hash_n<D: Digest>() -> impl Digest {
    let n = groups::GROUP_3072.n;
    // to_be_bytes makes a copy... :(
    let n_words: &groups::Words = n.as_words();
    // Use zerocopy to cast that to bytes.
    use zerocopy::IntoBytes;
    let n_bytes = n_words.as_bytes();
    // info!("g.n_bytes(): {:02?}", n_bytes);

    let mut hasher = D::new();
    // Oh man, this is all big endian instead of little endian...
    for b in n_bytes.iter().rev() {
        hasher.update(&[*b]);
    }
    hasher
}
fn hash_g<D: Digest>() -> impl Digest {
    let g = groups::GROUP_3072.g;
    let mut hasher = D::new();

    // This is fine, this allocates only 4 bytes on the stack.
    hasher.update(&[g as u8]);
    hasher
}

// This entire function depends on the group... why don't we pre-calculate this and put it in the group instead?
pub fn compute_k<D: Digest>(g: u32, n: &U3072) -> U3072 {
    // to_be_bytes makes a copy... :(
    let n_words: &groups::Words = n.as_words();
    // Use zerocopy to cast that to bytes.
    use zerocopy::IntoBytes;
    let n_bytes = n_words.as_bytes();
    // info!("g.n_bytes(): {:02?}", n_bytes);

    let mut hasher = D::new();
    // Oh man, this is all big endian instead of little endian...
    for b in n_bytes.iter().rev() {
        hasher.update(&[*b]);
    }
    for _b in 0..380 {
        hasher.update(&[0]);
    }
    // This is fine, this allocates only 4 bytes on the stack.
    hasher.update(&g.to_be_bytes());
    // info!("g.to_be_bytes(): {:?}", params.g.to_be_bytes());

    let hash_result = hasher.finalize();

    // Allocate the result on the stack, that's a must anyway.
    U3072::load_from_be(hash_result.as_slice())
}

// u = H(PAD(A) | PAD(B))
#[must_use]
pub fn compute_u<D: Digest>(a_pub: &[u8], b_pub: &[u8]) -> U3072 {
    let mut u = D::new();
    u.update(a_pub);
    u.update(b_pub);
    U3072::load_from_be(&u.finalize())
}

#[cfg(test)]
mod test {
    #![allow(non_upper_case_globals)]
    #![allow(dead_code)]
    use super::*;
    use num_bigint::BigUint;

    use crypto_bigint::{U128, U32768};
    implLoad!(U128);
    implLoad!(U32768);

    #[test]
    fn test_mulmod_modpow() {
        crate::test::init();

        // Check loading integers.
        let v = U128::load_from_be(&(0x1234567890abcdefu128 | (123u128 << 80)).to_be_bytes());
        info!("v: {:x?}\n", v);
        assert_eq!(v.as_words()[0], 0x1234567890abcdefu64); // word 0 is the low word.
        assert_eq!(v.as_words()[1], 123u64 << (80 - 64)); // word 1 is the high word.
        let z = v.to_be_bytes();
        let low = 0x1234567890abcdefu64.to_be_bytes();
        assert_eq!(&z[0 + 8..8 + 8], &low[0..8]);
        let zi = u128::from_be_bytes(z);
        assert_eq!(zi, 0x00000000007B00001234567890ABCDEFu128);

        // Check storing integers.
        let mut buffer = [0u8; 128 / 8];
        v.store_to_be(&mut buffer);
        assert_eq!(&buffer, &z);
        assert_eq!(&buffer, &zi.to_be_bytes());
        assert_eq!(&buffer, &v.to_be_bytes());

        // Ensure we can roundtrip with big endian bytes.
        assert_eq!(
            zi.to_be_bytes(),
            U128::load_from_be(&zi.to_be_bytes()).to_be_bytes()
        );

        // So all numbers are big endian, and they're stored big endian.

        // This is the goal:
        use srp::groups::G_3072;
        let ref_b = BigUint::from_bytes_be(&SRP_b);
        let ref_v = BigUint::from_bytes_be(&SRP_V);
        let ref_k = srp::utils::compute_k::<Sha512>(&G_3072);
        let ref_inter = (ref_k * ref_v) % &G_3072.n;
        let ref_inter_u3072 = U3072::load_from_be(&ref_inter.to_bytes_be());
        info!("ref_inter_u3072: {:x?}\n", ref_inter_u3072);

        // This is what we do:
        let bi = U3072::load_from_be(&SRP_b);
        let v = U3072::load_from_be(&SRP_V);
        let k = compute_k::<Sha512>(groups::GROUP_3072.g, groups::GROUP_3072.n);
        info!("bi: {:x?}   b: {}\n", bi, bi.bits());
        info!("v: {:x?}  b: {}\n", v, v.bits());
        info!(
            "n: {:x?}  b: {}\n",
            groups::GROUP_3072.n,
            groups::GROUP_3072.n.bits()
        );
        // First, lets do inter.
        // let inter = (k * v) % &self.params.n;
        let mut inter = k;
        info!("inter: {:x?}, b: {}\n", inter, inter.bits());

        // Now we have k in intermediate, all that remains is mult with v and modulo. Modulo is odd, so;
        // https://docs.rs/crypto-bigint/latest/crypto_bigint/struct.Uint.html#method.mul_mod
        // is applicable:
        let n = NonZero::new(*groups::GROUP_3072.n).unwrap();
        inter = inter.mul_mod(&v, &n);
        info!("k * v % n : {:x?}\n", inter);

        // Verify that matches.
        assert_eq!(ref_inter_u3072.to_be_bytes(), inter.to_be_bytes());

        // That checks off the first step, next lets do this mulmod thing.

        // In https://github.com/RustCrypto/PAKEs/blob/0be57fc1cf2ecb07f20a1b8bd15d6f9f069e2af8/srp/src/server.rs#L94
        // this is two steps:
        let ref_right = &G_3072.g.modpow(&ref_b, &G_3072.n);
        info!("ref_right: {:x?}\n", ref_right);
        let ref_right_u3072: U3072 = U3072::load_from_be(&ref_right.to_bytes_be());
        info!(
            "ref_right_u3072: {:x?}, {:?}\n",
            ref_right_u3072,
            ref_right_u3072.bits()
        );

        // Next we need  this modpow calculation.
        // g is the generator, b is the input data, and n is the prime. this is g^b % n
        // (inter + self.params.g.modpow(b, &self.params.n)) % &self.params.n

        let right_ours = groups::SRP_3072_G_CONST_MONTY.pow(&bi).retrieve();
        info!("right_ours: {:x?}, {:?}\n", right_ours, right_ours.bits());
        assert_eq!(right_ours.to_be_bytes(), ref_right_u3072.to_be_bytes());

        let combined = inter.add_mod(&right_ours, &groups::GROUP_3072.n);
        info!("combined: {:x?}, {:?}\n", combined, combined.bits());

        // Verify that our final result is correct.
        assert_eq!(combined, U3072::load_from_be(&SRP_B));
    }

    #[test]
    fn test_srp_reference() {
        crate::test::init();
        use srp::groups::G_3072;
        let server = srp::server::SrpServer::<Sha512>::new(&G_3072);
        let b_pub = server.compute_public_ephemeral(&SRP_b, &SRP_V);
        info!("srp_B: {:x?}", U3072::load_from_be(&b_pub));
        assert_eq!(b_pub, SRP_B);

        // Verifier SPR_V? seems to be the combination of user and pass.
        // Arguments for process reply are b,v,a_pub.
        // Process reply does the whole dance with b, v, a_pub, k, b_pub, u and the premaster key.
        println!("len SRP_b: {}", SRP_b.len());
        println!("len SRP_V: {}", SRP_V.len());
        println!("len SRP_A: {}", SRP_A.len());
        let verifier = server.process_reply(&SRP_b, SRP_V, &SRP_A).unwrap();
        // Ah, the hashing for m1 breaks from the implementation in 'srp'?
        // https://github.com/RustCrypto/PAKEs/issues/152
        //let m2 = verifier.proof();
        let premaster_secret = verifier.key();
        assert_eq!(premaster_secret, SRP_S); // matches.
        // assert!(verifier.verify_client(&SRP_m2).is_ok());
        //assert_eq!(m2, SRP_m2);
        // verifier.verify_client(reply) -> checks against m1
        // ------------------------------------------------------------------------
        // Done calculating the reference side

        let our_server = SrpServer::<Sha512>::new(&groups::GROUP_3072);
        //let mut our_b_pub = U3072::default();
        let mut our_b_pub = [0u8; 384];

        let before = std::time::Instant::now();
        our_server.compute_public_ephemeral(&SRP_b, &SRP_V, &mut our_b_pub);
        let after = (std::time::Instant::now() - before).as_micros();
        info!("our_b_pub: {our_b_pub:x?}, in {after} us");
        assert_eq!(U3072::load_from_be(&our_b_pub), U3072::load_from_be(&SRP_B));

        // next up is calculating the shared secret.
        let mut our_shared_secret = [0u8; 384];
        let before = std::time::Instant::now();
        let r = our_server.compute_shared_secret(
            &our_b_pub,
            &SRP_b,
            &SRP_V,
            &SRP_A,
            &mut our_shared_secret,
        );
        assert!(r.is_ok());
        assert_eq!(our_shared_secret, SRP_S);
        let after = (std::time::Instant::now() - before).as_micros();
        info!("our_shared_secret, in {after} us");

        let mut our_session_key = [0u8; 64];
        info!("our_shared_secret: {:02?}", &our_shared_secret);
        our_server.session_key(&our_shared_secret, &mut our_session_key);
        assert_eq!(&our_session_key, &SRP_k);
        let session_key = &our_session_key;

        // Next up, calculate the proofs?
        let mut our_m2 = [0u8; 64];
        our_server.compute_m2(&SRP_A, session_key, &SRP_m1, &mut our_m2);
        assert_eq!(&our_m2, SRP_m2);

        // Also make m1, because we need it to check against.
        //
        let username = SRP_USER;
        let salt = &SRP_SALT;
        let public_a = &SRP_A;
        let public_b = &our_b_pub;
        let mut our_m1 = [0u8; 64];

        our_server.compute_m1(username, salt, public_a, public_b, session_key, &mut our_m1);
        assert_eq!(&our_m1, SRP_m1);

        // let mut our_session_key = [0u8; 64];
        // our_server.session_key(shared_secret, &mut our_session_key);
        // pub fn session_key(&self, premaster_secret: &[u8], session_key: &mut [u8]) {}
    }

    // https://github.com/apple/HomeKitADK/blob/master/Tests/HAPCryptoTest.c#L165
    // https://github.com/wolfSSL/wolfssl/issues/18#issuecomment-83941582
    const SRP_SALT: [u8; 16] = [
        0xBE, 0xB2, 0x53, 0x79, 0xD1, 0xA8, 0x58, 0x1E, 0xB5, 0xA7, 0x27, 0x67, 0x3A, 0x24, 0x41,
        0xEE,
    ];
    const SRP_USER: &str = "alice";
    const SRP_PASS: &str = "password123";
    /// Verifier (v)
    const SRP_V: &[u8] = &[
        0x9b, 0x5e, 0x06, 0x17, 0x01, 0xea, 0x7a, 0xeb, 0x39, 0xcf, 0x6e, 0x35, 0x19, 0x65, 0x5a,
        0x85, 0x3c, 0xf9, 0x4c, 0x75, 0xca, 0xf2, 0x55, 0x5e, 0xf1, 0xfa, 0xf7, 0x59, 0xbb, 0x79,
        0xcb, 0x47, 0x70, 0x14, 0xe0, 0x4a, 0x88, 0xd6, 0x8f, 0xfc, 0x05, 0x32, 0x38, 0x91, 0xd4,
        0xc2, 0x05, 0xb8, 0xde, 0x81, 0xc2, 0xf2, 0x03, 0xd8, 0xfa, 0xd1, 0xb2, 0x4d, 0x2c, 0x10,
        0x97, 0x37, 0xf1, 0xbe, 0xbb, 0xd7, 0x1f, 0x91, 0x24, 0x47, 0xc4, 0xa0, 0x3c, 0x26, 0xb9,
        0xfa, 0xd8, 0xed, 0xb3, 0xe7, 0x80, 0x77, 0x8e, 0x30, 0x25, 0x29, 0xed, 0x1e, 0xe1, 0x38,
        0xcc, 0xfc, 0x36, 0xd4, 0xba, 0x31, 0x3c, 0xc4, 0x8b, 0x14, 0xea, 0x8c, 0x22, 0xa0, 0x18,
        0x6b, 0x22, 0x2e, 0x65, 0x5f, 0x2d, 0xf5, 0x60, 0x3f, 0xd7, 0x5d, 0xf7, 0x6b, 0x3b, 0x08,
        0xff, 0x89, 0x50, 0x06, 0x9a, 0xdd, 0x03, 0xa7, 0x54, 0xee, 0x4a, 0xe8, 0x85, 0x87, 0xcc,
        0xe1, 0xbf, 0xde, 0x36, 0x79, 0x4d, 0xba, 0xe4, 0x59, 0x2b, 0x7b, 0x90, 0x4f, 0x44, 0x2b,
        0x04, 0x1c, 0xb1, 0x7a, 0xeb, 0xad, 0x1e, 0x3a, 0xeb, 0xe3, 0xcb, 0xe9, 0x9d, 0xe6, 0x5f,
        0x4b, 0xb1, 0xfa, 0x00, 0xb0, 0xe7, 0xaf, 0x06, 0x86, 0x3d, 0xb5, 0x3b, 0x02, 0x25, 0x4e,
        0xc6, 0x6e, 0x78, 0x1e, 0x3b, 0x62, 0xa8, 0x21, 0x2c, 0x86, 0xbe, 0xb0, 0xd5, 0x0b, 0x5b,
        0xa6, 0xd0, 0xb4, 0x78, 0xd8, 0xc4, 0xe9, 0xbb, 0xce, 0xc2, 0x17, 0x65, 0x32, 0x6f, 0xbd,
        0x14, 0x05, 0x8d, 0x2b, 0xbd, 0xe2, 0xc3, 0x30, 0x45, 0xf0, 0x38, 0x73, 0xe5, 0x39, 0x48,
        0xd7, 0x8b, 0x79, 0x4f, 0x07, 0x90, 0xe4, 0x8c, 0x36, 0xae, 0xd6, 0xe8, 0x80, 0xf5, 0x57,
        0x42, 0x7b, 0x2f, 0xc0, 0x6d, 0xb5, 0xe1, 0xe2, 0xe1, 0xd7, 0xe6, 0x61, 0xac, 0x48, 0x2d,
        0x18, 0xe5, 0x28, 0xd7, 0x29, 0x5e, 0xf7, 0x43, 0x72, 0x95, 0xff, 0x1a, 0x72, 0xd4, 0x02,
        0x77, 0x17, 0x13, 0xf1, 0x68, 0x76, 0xdd, 0x05, 0x0a, 0xe5, 0xb7, 0xad, 0x53, 0xcc, 0xb9,
        0x08, 0x55, 0xc9, 0x39, 0x56, 0x64, 0x83, 0x58, 0xad, 0xfd, 0x96, 0x64, 0x22, 0xf5, 0x24,
        0x98, 0x73, 0x2d, 0x68, 0xd1, 0xd7, 0xfb, 0xef, 0x10, 0xd7, 0x80, 0x34, 0xab, 0x8d, 0xcb,
        0x6f, 0x0f, 0xcf, 0x88, 0x5c, 0xc2, 0xb2, 0xea, 0x2c, 0x3e, 0x6a, 0xc8, 0x66, 0x09, 0xea,
        0x05, 0x8a, 0x9d, 0xa8, 0xcc, 0x63, 0x53, 0x1d, 0xc9, 0x15, 0x41, 0x4d, 0xf5, 0x68, 0xb0,
        0x94, 0x82, 0xdd, 0xac, 0x19, 0x54, 0xde, 0xc7, 0xeb, 0x71, 0x4f, 0x6f, 0xf7, 0xd4, 0x4c,
        0xd5, 0xb8, 0x6f, 0x6b, 0xd1, 0x15, 0x81, 0x09, 0x30, 0x63, 0x7c, 0x01, 0xd0, 0xf6, 0x01,
        0x3b, 0xc9, 0x74, 0x0f, 0xa2, 0xc6, 0x33, 0xba, 0x89,
    ];
    /// B Private (b)
    const SRP_b: &[u8] = &[
        0xe4, 0x87, 0xcb, 0x59, 0xd3, 0x1a, 0xc5, 0x50, 0x47, 0x1e, 0x81, 0xf0, 0x0f, 0x69, 0x28,
        0xe0, 0x1d, 0xda, 0x08, 0xe9, 0x74, 0xa0, 0x04, 0xf4, 0x9e, 0x61, 0xf5, 0xd1, 0x05, 0x28,
        0x4d, 0x20,
    ];
    /// A Public (A)
    const SRP_A: &[u8] = &[
        0xfa, 0xb6, 0xf5, 0xd2, 0x61, 0x5d, 0x1e, 0x32, 0x35, 0x12, 0xe7, 0x99, 0x1c, 0xc3, 0x74,
        0x43, 0xf4, 0x87, 0xda, 0x60, 0x4c, 0xa8, 0xc9, 0x23, 0x0f, 0xcb, 0x04, 0xe5, 0x41, 0xdc,
        0xe6, 0x28, 0x0b, 0x27, 0xca, 0x46, 0x80, 0xb0, 0x37, 0x4f, 0x17, 0x9d, 0xc3, 0xbd, 0xc7,
        0x55, 0x3f, 0xe6, 0x24, 0x59, 0x79, 0x8c, 0x70, 0x1a, 0xd8, 0x64, 0xa9, 0x13, 0x90, 0xa2,
        0x8c, 0x93, 0xb6, 0x44, 0xad, 0xbf, 0x9c, 0x00, 0x74, 0x5b, 0x94, 0x2b, 0x79, 0xf9, 0x01,
        0x2a, 0x21, 0xb9, 0xb7, 0x87, 0x82, 0x31, 0x9d, 0x83, 0xa1, 0xf8, 0x36, 0x28, 0x66, 0xfb,
        0xd6, 0xf4, 0x6b, 0xfc, 0x0d, 0xdb, 0x2e, 0x1a, 0xb6, 0xe4, 0xb4, 0x5a, 0x99, 0x06, 0xb8,
        0x2e, 0x37, 0xf0, 0x5d, 0x6f, 0x97, 0xf6, 0xa3, 0xeb, 0x6e, 0x18, 0x20, 0x79, 0x75, 0x9c,
        0x4f, 0x68, 0x47, 0x83, 0x7b, 0x62, 0x32, 0x1a, 0xc1, 0xb4, 0xfa, 0x68, 0x64, 0x1f, 0xcb,
        0x4b, 0xb9, 0x8d, 0xd6, 0x97, 0xa0, 0xc7, 0x36, 0x41, 0x38, 0x5f, 0x4b, 0xab, 0x25, 0xb7,
        0x93, 0x58, 0x4c, 0xc3, 0x9f, 0xc8, 0xd4, 0x8d, 0x4b, 0xd8, 0x67, 0xa9, 0xa3, 0xc1, 0x0f,
        0x8e, 0xa1, 0x21, 0x70, 0x26, 0x8e, 0x34, 0xfe, 0x3b, 0xbe, 0x6f, 0xf8, 0x99, 0x98, 0xd6,
        0x0d, 0xa2, 0xf3, 0xe4, 0x28, 0x3c, 0xbe, 0xc1, 0x39, 0x3d, 0x52, 0xaf, 0x72, 0x4a, 0x57,
        0x23, 0x0c, 0x60, 0x4e, 0x9f, 0xbc, 0xe5, 0x83, 0xd7, 0x61, 0x3e, 0x6b, 0xff, 0xd6, 0x75,
        0x96, 0xad, 0x12, 0x1a, 0x87, 0x07, 0xee, 0xc4, 0x69, 0x44, 0x95, 0x70, 0x33, 0x68, 0x6a,
        0x15, 0x5f, 0x64, 0x4d, 0x5c, 0x58, 0x63, 0xb4, 0x8f, 0x61, 0xbd, 0xbf, 0x19, 0xa5, 0x3e,
        0xab, 0x6d, 0xad, 0x0a, 0x18, 0x6b, 0x8c, 0x15, 0x2e, 0x5f, 0x5d, 0x8c, 0xad, 0x4b, 0x0e,
        0xf8, 0xaa, 0x4e, 0xa5, 0x00, 0x88, 0x34, 0xc3, 0xcd, 0x34, 0x2e, 0x5e, 0x0f, 0x16, 0x7a,
        0xd0, 0x45, 0x92, 0xcd, 0x8b, 0xd2, 0x79, 0x63, 0x93, 0x98, 0xef, 0x9e, 0x11, 0x4d, 0xfa,
        0xaa, 0xb9, 0x19, 0xe1, 0x4e, 0x85, 0x09, 0x89, 0x22, 0x4d, 0xdd, 0x98, 0x57, 0x6d, 0x79,
        0x38, 0x5d, 0x22, 0x10, 0x90, 0x2e, 0x9f, 0x9b, 0x1f, 0x2d, 0x86, 0xcf, 0xa4, 0x7e, 0xe2,
        0x44, 0x63, 0x54, 0x65, 0xf7, 0x10, 0x58, 0x42, 0x1a, 0x01, 0x84, 0xbe, 0x51, 0xdd, 0x10,
        0xcc, 0x9d, 0x07, 0x9e, 0x6f, 0x16, 0x04, 0xe7, 0xaa, 0x9b, 0x7c, 0xf7, 0x88, 0x3c, 0x7d,
        0x4c, 0xe1, 0x2b, 0x06, 0xeb, 0xe1, 0x60, 0x81, 0xe2, 0x3f, 0x27, 0xa2, 0x31, 0xd1, 0x84,
        0x32, 0xd7, 0xd1, 0xbb, 0x55, 0xc2, 0x8a, 0xe2, 0x1f, 0xfc, 0xf0, 0x05, 0xf5, 0x75, 0x28,
        0xd1, 0x5a, 0x88, 0x88, 0x1b, 0xb3, 0xbb, 0xb7, 0xfe,
    ];

    /// B Public (B)
    const SRP_B: &[u8] = &[
        0x40, 0xf5, 0x70, 0x88, 0xa4, 0x82, 0xd4, 0xc7, 0x73, 0x33, 0x84, 0xfe, 0x0d, 0x30, 0x1f,
        0xdd, 0xca, 0x90, 0x80, 0xad, 0x7d, 0x4f, 0x6f, 0xdf, 0x09, 0xa0, 0x10, 0x06, 0xc3, 0xcb,
        0x6d, 0x56, 0x2e, 0x41, 0x63, 0x9a, 0xe8, 0xfa, 0x21, 0xde, 0x3b, 0x5d, 0xba, 0x75, 0x85,
        0xb2, 0x75, 0x58, 0x9b, 0xdb, 0x27, 0x98, 0x63, 0xc5, 0x62, 0x80, 0x7b, 0x2b, 0x99, 0x08,
        0x3c, 0xd1, 0x42, 0x9c, 0xdb, 0xe8, 0x9e, 0x25, 0xbf, 0xbd, 0x7e, 0x3c, 0xad, 0x31, 0x73,
        0xb2, 0xe3, 0xc5, 0xa0, 0xb1, 0x74, 0xda, 0x6d, 0x53, 0x91, 0xe6, 0xa0, 0x6e, 0x46, 0x5f,
        0x03, 0x7a, 0x40, 0x06, 0x25, 0x48, 0x39, 0xa5, 0x6b, 0xf7, 0x6d, 0xa8, 0x4b, 0x1c, 0x94,
        0xe0, 0xae, 0x20, 0x85, 0x76, 0x15, 0x6f, 0xe5, 0xc1, 0x40, 0xa4, 0xba, 0x4f, 0xfc, 0x9e,
        0x38, 0xc3, 0xb0, 0x7b, 0x88, 0x84, 0x5f, 0xc6, 0xf7, 0xdd, 0xda, 0x93, 0x38, 0x1f, 0xe0,
        0xca, 0x60, 0x84, 0xc4, 0xcd, 0x2d, 0x33, 0x6e, 0x54, 0x51, 0xc4, 0x64, 0xcc, 0xb6, 0xec,
        0x65, 0xe7, 0xd1, 0x6e, 0x54, 0x8a, 0x27, 0x3e, 0x82, 0x62, 0x84, 0xaf, 0x25, 0x59, 0xb6,
        0x26, 0x42, 0x74, 0x21, 0x59, 0x60, 0xff, 0xf4, 0x7b, 0xdd, 0x63, 0xd3, 0xaf, 0xf0, 0x64,
        0xd6, 0x13, 0x7a, 0xf7, 0x69, 0x66, 0x1c, 0x9d, 0x4f, 0xee, 0x47, 0x38, 0x26, 0x03, 0xc8,
        0x8e, 0xaa, 0x09, 0x80, 0x58, 0x1d, 0x07, 0x75, 0x84, 0x61, 0xb7, 0x77, 0xe4, 0x35, 0x6d,
        0xda, 0x58, 0x35, 0x19, 0x8b, 0x51, 0xfe, 0xea, 0x30, 0x8d, 0x70, 0xf7, 0x54, 0x50, 0xb7,
        0x16, 0x75, 0xc0, 0x8c, 0x7d, 0x83, 0x02, 0xfd, 0x75, 0x39, 0xdd, 0x1f, 0xf2, 0xa1, 0x1c,
        0xb4, 0x25, 0x8a, 0xa7, 0x0d, 0x23, 0x44, 0x36, 0xaa, 0x42, 0xb6, 0xa0, 0x61, 0x5f, 0x3f,
        0x91, 0x5d, 0x55, 0xcc, 0x3b, 0x96, 0x6b, 0x27, 0x16, 0xb3, 0x6e, 0x4d, 0x1a, 0x06, 0xce,
        0x5e, 0x5d, 0x2e, 0xa3, 0xbe, 0xe5, 0xa1, 0x27, 0x0e, 0x87, 0x51, 0xda, 0x45, 0xb6, 0x0b,
        0x99, 0x7b, 0x0f, 0xfd, 0xb0, 0xf9, 0x96, 0x2f, 0xee, 0x4f, 0x03, 0xbe, 0xe7, 0x80, 0xba,
        0x0a, 0x84, 0x5b, 0x1d, 0x92, 0x71, 0x42, 0x17, 0x83, 0xae, 0x66, 0x01, 0xa6, 0x1e, 0xa2,
        0xe3, 0x42, 0xe4, 0xf2, 0xe8, 0xbc, 0x93, 0x5a, 0x40, 0x9e, 0xad, 0x19, 0xf2, 0x21, 0xbd,
        0x1b, 0x74, 0xe2, 0x96, 0x4d, 0xd1, 0x9f, 0xc8, 0x45, 0xf6, 0x0e, 0xfc, 0x09, 0x33, 0x8b,
        0x60, 0xb6, 0xb2, 0x56, 0xd8, 0xca, 0xc8, 0x89, 0xcc, 0xa3, 0x06, 0xcc, 0x37, 0x0a, 0x0b,
        0x18, 0xc8, 0xb8, 0x86, 0xe9, 0x5d, 0xa0, 0xaf, 0x52, 0x35, 0xfe, 0xf4, 0x39, 0x30, 0x20,
        0xd2, 0xb7, 0xf3, 0x05, 0x69, 0x04, 0x75, 0x90, 0x42,
    ];

    /// Random scrambling parameter (u)
    const SRP_u: &[u8] = &[
        0x03, 0xae, 0x5f, 0x3c, 0x3f, 0xa9, 0xef, 0xf1, 0xa5, 0x0d, 0x7d, 0xbb, 0x8d, 0x2f, 0x60,
        0xa1, 0xea, 0x66, 0xea, 0x71, 0x2d, 0x50, 0xae, 0x97, 0x6e, 0xe3, 0x46, 0x41, 0xa1, 0xcd,
        0x0e, 0x51, 0xc4, 0x68, 0x3d, 0xa3, 0x83, 0xe8, 0x59, 0x5d, 0x6c, 0xb5, 0x6a, 0x15, 0xd5,
        0xfb, 0xc7, 0x54, 0x3e, 0x07, 0xfb, 0xdd, 0xd3, 0x16, 0x21, 0x7e, 0x01, 0xa3, 0x91, 0xa1,
        0x8e, 0xf0, 0x6d, 0xff,
    ];

    /// Premaster secret (S), shared secret.
    const SRP_S: &[u8] = &[
        0xf1, 0x03, 0x6f, 0xec, 0xd0, 0x17, 0xc8, 0x23, 0x9c, 0x0d, 0x5a, 0xf7, 0xe0, 0xfc, 0xf0,
        0xd4, 0x08, 0xb0, 0x09, 0xe3, 0x64, 0x11, 0x61, 0x8a, 0x60, 0xb2, 0x3a, 0xab, 0xbf, 0xc3,
        0x83, 0x39, 0x72, 0x68, 0x23, 0x12, 0x14, 0xba, 0xac, 0xdc, 0x94, 0xca, 0x1c, 0x53, 0xf4,
        0x42, 0xfb, 0x51, 0xc1, 0xb0, 0x27, 0xc3, 0x18, 0xae, 0x23, 0x8e, 0x16, 0x41, 0x4d, 0x60,
        0xd1, 0x88, 0x1b, 0x66, 0x48, 0x6a, 0xde, 0x10, 0xed, 0x02, 0xba, 0x33, 0xd0, 0x98, 0xf6,
        0xce, 0x9b, 0xcf, 0x1b, 0xb0, 0xc4, 0x6c, 0xa2, 0xc4, 0x7f, 0x2f, 0x17, 0x4c, 0x59, 0xa9,
        0xc6, 0x1e, 0x25, 0x60, 0x89, 0x9b, 0x83, 0xef, 0x61, 0x13, 0x1e, 0x6f, 0xb3, 0x0b, 0x71,
        0x4f, 0x4e, 0x43, 0xb7, 0x35, 0xc9, 0xfe, 0x60, 0x80, 0x47, 0x7c, 0x1b, 0x83, 0xe4, 0x09,
        0x3e, 0x4d, 0x45, 0x6b, 0x9b, 0xca, 0x49, 0x2c, 0xf9, 0x33, 0x9d, 0x45, 0xbc, 0x42, 0xe6,
        0x7c, 0xe6, 0xc0, 0x2c, 0x24, 0x3e, 0x49, 0xf5, 0xda, 0x42, 0xa8, 0x69, 0xec, 0x85, 0x57,
        0x80, 0xe8, 0x42, 0x07, 0xb8, 0xa1, 0xea, 0x65, 0x01, 0xc4, 0x78, 0xaa, 0xc0, 0xdf, 0xd3,
        0xd2, 0x26, 0x14, 0xf5, 0x31, 0xa0, 0x0d, 0x82, 0x6b, 0x79, 0x54, 0xae, 0x8b, 0x14, 0xa9,
        0x85, 0xa4, 0x29, 0x31, 0x5e, 0x6d, 0xd3, 0x66, 0x4c, 0xf4, 0x71, 0x81, 0x49, 0x6a, 0x94,
        0x32, 0x9c, 0xde, 0x80, 0x05, 0xca, 0xe6, 0x3c, 0x2f, 0x9c, 0xa4, 0x96, 0x9b, 0xfe, 0x84,
        0x00, 0x19, 0x24, 0x03, 0x7c, 0x44, 0x65, 0x59, 0xbd, 0xbb, 0x9d, 0xb9, 0xd4, 0xdd, 0x14,
        0x2f, 0xbc, 0xd7, 0x5e, 0xef, 0x2e, 0x16, 0x2c, 0x84, 0x30, 0x65, 0xd9, 0x9e, 0x8f, 0x05,
        0x76, 0x2c, 0x4d, 0xb7, 0xab, 0xd9, 0xdb, 0x20, 0x3d, 0x41, 0xac, 0x85, 0xa5, 0x8c, 0x05,
        0xbd, 0x4e, 0x2d, 0xbf, 0x82, 0x2a, 0x93, 0x45, 0x23, 0xd5, 0x4e, 0x06, 0x53, 0xd3, 0x76,
        0xce, 0x8b, 0x56, 0xdc, 0xb4, 0x52, 0x7d, 0xdd, 0xc1, 0xb9, 0x94, 0xdc, 0x75, 0x09, 0x46,
        0x3a, 0x74, 0x68, 0xd7, 0xf0, 0x2b, 0x1b, 0xeb, 0x16, 0x85, 0x71, 0x4c, 0xe1, 0xdd, 0x1e,
        0x71, 0x80, 0x8a, 0x13, 0x7f, 0x78, 0x88, 0x47, 0xb7, 0xc6, 0xb7, 0xbf, 0xa1, 0x36, 0x44,
        0x74, 0xb3, 0xb7, 0xe8, 0x94, 0x78, 0x95, 0x4f, 0x6a, 0x8e, 0x68, 0xd4, 0x5b, 0x85, 0xa8,
        0x8e, 0x4e, 0xbf, 0xec, 0x13, 0x36, 0x8e, 0xc0, 0x89, 0x1c, 0x3b, 0xc8, 0x6c, 0xf5, 0x00,
        0x97, 0x88, 0x01, 0x78, 0xd8, 0x61, 0x35, 0xe7, 0x28, 0x72, 0x34, 0x58, 0x53, 0x88, 0x58,
        0xd7, 0x15, 0xb7, 0xb2, 0x47, 0x40, 0x62, 0x22, 0xc1, 0x01, 0x9f, 0x53, 0x60, 0x3f, 0x01,
        0x69, 0x52, 0xd4, 0x97, 0x10, 0x08, 0x58, 0x82, 0x4c,
    ];

    /// Session Key (K)
    const SRP_k: &[u8] = &[
        0x5c, 0xbc, 0x21, 0x9d, 0xb0, 0x52, 0x13, 0x8e, 0xe1, 0x14, 0x8c, 0x71, 0xcd, 0x44, 0x98,
        0x96, 0x3d, 0x68, 0x25, 0x49, 0xce, 0x91, 0xca, 0x24, 0xf0, 0x98, 0x46, 0x8f, 0x06, 0x01,
        0x5b, 0xeb, 0x6a, 0xf2, 0x45, 0xc2, 0x09, 0x3f, 0x98, 0xc3, 0x65, 0x1b, 0xca, 0x83, 0xab,
        0x8c, 0xab, 0x2b, 0x58, 0x0b, 0xbf, 0x02, 0x18, 0x4f, 0xef, 0xdf, 0x26, 0x14, 0x2f, 0x73,
        0xdf, 0x95, 0xac, 0x50,
    ];
    /// Client's proof
    const SRP_m1: &[u8] = &[
        0x5f, 0x7c, 0x14, 0xab, 0x57, 0xed, 0x0e, 0x94, 0xfd, 0x1d, 0x78, 0xc6, 0xb4, 0xdd, 0x09,
        0xed, 0x7e, 0x34, 0x0b, 0x7e, 0x05, 0xd4, 0x19, 0xa9, 0xfd, 0x76, 0x0f, 0x6b, 0x35, 0xe5,
        0x23, 0xd1, 0x31, 0x07, 0x77, 0xa1, 0xae, 0x1d, 0x28, 0x26, 0xf5, 0x96, 0xf3, 0xa8, 0x51,
        0x16, 0xcc, 0x45, 0x7c, 0x7c, 0x96, 0x4d, 0x4f, 0x44, 0xde, 0xd5, 0x55, 0x9d, 0xa8, 0x18,
        0xc8, 0x8b, 0x61, 0x7f,
    ];
    /// Server's proof
    const SRP_m2: &[u8] = &[
        0x2f, 0xa0, 0xe8, 0x1f, 0x5c, 0xb7, 0x3b, 0x88, 0xfa, 0x09, 0x64, 0x27, 0x0f, 0x32, 0x1d,
        0xd6, 0x41, 0xf2, 0x22, 0x7a, 0x5d, 0x80, 0x5c, 0x40, 0xf1, 0xbf, 0xe9, 0x6a, 0xaf, 0x6a,
        0x19, 0xff, 0xce, 0x8e, 0x23, 0x28, 0x79, 0x65, 0xa3, 0x9e, 0xab, 0x9d, 0x5a, 0x02, 0x21,
        0x5f, 0x89, 0xe1, 0x28, 0x17, 0x7e, 0xd2, 0xc4, 0xf1, 0x03, 0xe6, 0x55, 0xa0, 0x45, 0x53,
        0x1b, 0xcb, 0xf7, 0xad,
    ];
}

use crypto_bigint::impl_modulus;
use crypto_bigint::modular::ConstMontyParams;
impl_modulus!(
    Srp3072Modulus,
    U3072,
    "FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6BF12FFA06D98A0864D87602733EC86A64521F2B18177B200CBBE117577A615D6C770988C0BAD946E208E24FA074E5AB3143DB5BFCE0FD108E4B82D120A93AD2CAFFFFFFFFFFFFFFFF"
);
pub type Srp3072ConstMontyForm =
    crypto_bigint::modular::ConstMontyForm<Srp3072Modulus, { U3072::LIMBS }>;

pub mod groups {
    use super::*;
    use lazy_static::lazy_static;

    lazy_static! {
        static ref GROUP_3072_N: U3072 = U3072::from_be_slice(&[
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc9, 0x0f, 0xda, 0xa2, 0x21, 0x68,
            0xc2, 0x34, 0xc4, 0xc6, 0x62, 0x8b, 0x80, 0xdc, 0x1c, 0xd1, 0x29, 0x02, 0x4e, 0x08,
            0x8a, 0x67, 0xcc, 0x74, 0x02, 0x0b, 0xbe, 0xa6, 0x3b, 0x13, 0x9b, 0x22, 0x51, 0x4a,
            0x08, 0x79, 0x8e, 0x34, 0x04, 0xdd, 0xef, 0x95, 0x19, 0xb3, 0xcd, 0x3a, 0x43, 0x1b,
            0x30, 0x2b, 0x0a, 0x6d, 0xf2, 0x5f, 0x14, 0x37, 0x4f, 0xe1, 0x35, 0x6d, 0x6d, 0x51,
            0xc2, 0x45, 0xe4, 0x85, 0xb5, 0x76, 0x62, 0x5e, 0x7e, 0xc6, 0xf4, 0x4c, 0x42, 0xe9,
            0xa6, 0x37, 0xed, 0x6b, 0x0b, 0xff, 0x5c, 0xb6, 0xf4, 0x06, 0xb7, 0xed, 0xee, 0x38,
            0x6b, 0xfb, 0x5a, 0x89, 0x9f, 0xa5, 0xae, 0x9f, 0x24, 0x11, 0x7c, 0x4b, 0x1f, 0xe6,
            0x49, 0x28, 0x66, 0x51, 0xec, 0xe4, 0x5b, 0x3d, 0xc2, 0x00, 0x7c, 0xb8, 0xa1, 0x63,
            0xbf, 0x05, 0x98, 0xda, 0x48, 0x36, 0x1c, 0x55, 0xd3, 0x9a, 0x69, 0x16, 0x3f, 0xa8,
            0xfd, 0x24, 0xcf, 0x5f, 0x83, 0x65, 0x5d, 0x23, 0xdc, 0xa3, 0xad, 0x96, 0x1c, 0x62,
            0xf3, 0x56, 0x20, 0x85, 0x52, 0xbb, 0x9e, 0xd5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6d,
            0x67, 0x0c, 0x35, 0x4e, 0x4a, 0xbc, 0x98, 0x04, 0xf1, 0x74, 0x6c, 0x08, 0xca, 0x18,
            0x21, 0x7c, 0x32, 0x90, 0x5e, 0x46, 0x2e, 0x36, 0xce, 0x3b, 0xe3, 0x9e, 0x77, 0x2c,
            0x18, 0x0e, 0x86, 0x03, 0x9b, 0x27, 0x83, 0xa2, 0xec, 0x07, 0xa2, 0x8f, 0xb5, 0xc5,
            0x5d, 0xf0, 0x6f, 0x4c, 0x52, 0xc9, 0xde, 0x2b, 0xcb, 0xf6, 0x95, 0x58, 0x17, 0x18,
            0x39, 0x95, 0x49, 0x7c, 0xea, 0x95, 0x6a, 0xe5, 0x15, 0xd2, 0x26, 0x18, 0x98, 0xfa,
            0x05, 0x10, 0x15, 0x72, 0x8e, 0x5a, 0x8a, 0xaa, 0xc4, 0x2d, 0xad, 0x33, 0x17, 0x0d,
            0x04, 0x50, 0x7a, 0x33, 0xa8, 0x55, 0x21, 0xab, 0xdf, 0x1c, 0xba, 0x64, 0xec, 0xfb,
            0x85, 0x04, 0x58, 0xdb, 0xef, 0x0a, 0x8a, 0xea, 0x71, 0x57, 0x5d, 0x06, 0x0c, 0x7d,
            0xb3, 0x97, 0x0f, 0x85, 0xa6, 0xe1, 0xe4, 0xc7, 0xab, 0xf5, 0xae, 0x8c, 0xdb, 0x09,
            0x33, 0xd7, 0x1e, 0x8c, 0x94, 0xe0, 0x4a, 0x25, 0x61, 0x9d, 0xce, 0xe3, 0xd2, 0x26,
            0x1a, 0xd2, 0xee, 0x6b, 0xf1, 0x2f, 0xfa, 0x06, 0xd9, 0x8a, 0x08, 0x64, 0xd8, 0x76,
            0x02, 0x73, 0x3e, 0xc8, 0x6a, 0x64, 0x52, 0x1f, 0x2b, 0x18, 0x17, 0x7b, 0x20, 0x0c,
            0xbb, 0xe1, 0x17, 0x57, 0x7a, 0x61, 0x5d, 0x6c, 0x77, 0x09, 0x88, 0xc0, 0xba, 0xd9,
            0x46, 0xe2, 0x08, 0xe2, 0x4f, 0xa0, 0x74, 0xe5, 0xab, 0x31, 0x43, 0xdb, 0x5b, 0xfc,
            0xe0, 0xfd, 0x10, 0x8e, 0x4b, 0x82, 0xd1, 0x20, 0xa9, 0x3a, 0xd2, 0xca, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        ]);
        static ref GROUP_3072_NZ: NonZero<U3072> = NonZero::new(*GROUP_3072_N).unwrap();
        //static ref GROUP_3072_K: U3072 = compute_k(5, &GROUP_3072_N);
        // https://datatracker.ietf.org/doc/html/rfc5054#page-16
        pub static ref GROUP_3072: SrpGroup = SrpGroup {
            g: 5,
            n: &GROUP_3072_N,
            nz: &GROUP_3072_NZ,
            //k: &GROUP_3072_K,
        };




    }

    #[cfg(target_pointer_width = "64")]
    pub type ConstMontyForm = crypto_bigint::modular::ConstMontyForm<Srp3072Modulus, 48>;
    #[cfg(target_pointer_width = "32")]
    pub type ConstMontyForm = crypto_bigint::modular::ConstMontyForm<Srp3072Modulus, 96>;

    #[cfg(target_pointer_width = "64")]
    pub type Words = [u64; 3072 / 64];
    #[cfg(target_pointer_width = "32")]
    pub type Words = [u32; 3072 / 32];

    lazy_static! {
        pub static ref SRP_3072_CONST_MONTY: ConstMontyForm = Srp3072ConstMontyForm::default();
        pub static ref SRP_3072_G_CONST_MONTY: ConstMontyForm = {
            let m = U3072::from_u8(5);
            const_monty_form!(m, Srp3072Modulus)
        };
    }
}
